---
title: 服务治理
lang: zh-cn
---

## 服务治理的概念

服务治理是主要针对分布式服务框架、微服务，处理服务调用之间的关系，服务发布和发现（谁是提供者，谁是消费者，要注册到哪里），出了故障谁调用谁，服务的参数都有哪些约束,如何保证服务的质量？如何服务降级和熔断？怎么让服务受到监控，提高机器的利用率?

微服务有哪些问题需要治理？

1. **服务注册与发现**: 单体服务拆分为微服务后，如果微服务之间存在调用依赖，就需要得到目标服务的服务地址，也就是微服务治理的 **服务发现** 。要完成服务发现，就需要将服务信息存储到某个载体，载体本身即是微服务治理的*服务注册中心*，而存储到载体的动作即是*服务注册*。

2. **可观测性**: 微服务由于较单体应用有了更多的部署载体，需要对众多服务间的调用关系、状态有清晰的掌控。可观测性就包括了调用拓扑关系、监控（Metrics）、日志（Logging）、调用追踪（Trace）等。

3. **流量管理**: 由于微服务本身存在不同版本，在版本更迭过程中，需要对微服务间调用进行控制，以完成微服务版本更迭的平滑。这一过程中需要根据流量的特征（访问参数等）、百分比向不同版本服务分发，这也孵化出灰度发布、蓝绿发布、A/B测试等服务治理的细分主题。

4. **服务容错**: 任何服务都不能保证100%不出问题，生产环境复杂多变，服务运行过程中不可避免的发生各种故障（宕机、过载等等），工程师能够做的是在故障发生时尽可能降低影响范围、尽快恢复正常服务,需要引入「熔断、隔离、限流和降级、超时机制」等「服务容错」机制来保证服务持续可用性。

4. **安全**: 不同微服务承载自身独有的业务职责，对于业务敏感的微服务，需要对其他服务的访问进行认证与鉴权，也就是安全问题。

5. **控制**： 对服务治理能力充分建设后，就需要有足够的控制能力，能实时进行服务治理策略向微服务分发。

6. **服务本身的治理**: 确保微服务主机的健康,有能力将不健康节点从微服务集群中移除。

## 服务注册与发现

silky支持服务的自动注册和发现,支持使用 **Zookeeper** 、**Nacos** 、**Consul** 作为服务注册中心。服务实例上线、下线智能感知。

1. 当服务实例启动时,会向服务注册中心新增或是更新服务元数据(*如果不存在新增服务元数据、如果存在服务元数据则更新*);同时,更新服务注册中心该实例的终结点(实例地址信息)。

2. 使用 **Zookeeper** 或是 **Nacos** 作为服务注册中心,会通过 **发布-订阅** 的方式从服务注册中心获取最新的服务元数据和服务实例的终结点(实例地址)信息,并更新到本地内存;

3. 如果使用 **Consul** 作为服务注册中心，则会通过心跳的方式从服务注册中心 **拉取** 最新的服务元数据和服务实例的终结点(实例地址)信息。当服务注册中心的终结点(地址信息)发生变化,服务实例的内存中服务路由表信息也将得到更新。

4. 当服务在RPC通信过程中发生IO异常或是通信异常时,会在配置的n(配置属性为:`Governance:UnHealthAddressTimesAllowedBeforeRemoving`)次后,从服务注册中心移除。(`UnHealthAddressTimesAllowedBeforeRemoving`如果的值等于0,则服务实例将会被立即移除)。

5. 在RPC通信过程中,采用长链接, 支持心跳检测。在服务之间建立连接后,如果`Governance:EnableHeartbeat`配置为`true`，那么会定时(通过配置`Governance:HeartbeatWatchIntervalSeconds`)发送一个心跳包,从而保证会话链接的可靠性。如果心跳检测到通信异常,则会根据配置属性(`Governance:UnHealthAddressTimesAllowedBeforeRemoving`)n次后,从服务注册中心移除。

## 负载均衡

在RPC通信过程中,silky框架支持 **轮询(Polling)**、 **随机(Random)** 、 **哈希一致性(HashAlgorithm)** 等负载均衡算法。负载均衡的缺省值为 **轮询(Polling)** ,开发者可以通过配置属性 `Governance:ShuntStrategy` 来统一指定负载均衡算法。同时,开发者也可以通过`GovernanceAttribute`特性来重置应用服务方法(服务条目)的负载均衡算法。

例如:

```csharp
[HttpGet("{name}")]
[Governance(ShuntStrategy = ShuntStrategy.HashAlgorithm)]
Task<TestOut> Get([HashKey]string name);
```

如果选择使用 **哈希一致性(HashAlgorithm)** 作为负载均衡算法,则需要使用`[HashKey]`对某一个参数进行标识,这样,相同参数的请求,在RPC通信过程中,都会被路由到通一个服务实例。

## 超时

## 失败重试

## 熔断保护(断路器)

## 限流

## 失败回退

## 链路跟踪

## 服务保护

## 缓存拦截