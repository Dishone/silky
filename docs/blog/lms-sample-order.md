# lms框架分布式事务简介

lms框架的分布式事务解决方案采用的TCC事务模型。在开发过程中参考和借鉴了[hmily](https://github.com/dromara/hmily)。使用AOP的编程思想,在rpc通信过程中通过拦截器的方式对全局事务或是分支事务进行管理和协调。

本文通过lms.samples 订单接口给大家介绍lms框架分布式事务的基本使用。

## lms.samples 订单接口简介

在上一篇博文[通过lms.samples熟悉lms微服务框架的使用](https://www.cnblogs.com/bea084100123/p/14631609.html)，给大家介绍了lms.samples样例项目的基本情况。本文通过大家熟悉的一个订单接口,熟悉lms的分布式事务是如何使用。

下面，给大家梳理一下订单接口的业务流程。

1. 判断和锁定订单产品库存: 在下订单之前需要判断是否存在相应的产品,产品的剩余数量是否足够，如果产品数量足够的话,扣减产品库存,锁定订单的库存数量(分支事务)

2. 创建一个订单记录,订单状态为NoPay(全局事务)

3. 判断用户的账号是否存在,账户余额是否充足,如果账户余额充足的话,则需要锁定订单金额，创建一个账户流水记录。

4. 如果1,2,3都成功,释放产品锁定的订单库存

5. 如果1,2,3都成功,释放账号锁定的金额,修改账号流水记录相关状态

6. 如果1,2,3都成功,修改订单状态为Payed

7. 如果在**步骤1**就出现异常(例如:产品的库存不足或是rpc通信失败,或是访问数据库出现异常等),库存分支事务(`DeductStockCancel`)和账号分支事务(`DeductBalanceCancel`)指定的`Cancel`方法都不会被执行。但是全局事务指定的`Cancel`方法(`OrderCreateCancel`)会被调用

8. 如果在**步骤2**就出现异常(下订单访问数据库出现异常),库存分支事务指定的`Cancel`方法(`DeductStockCancel`)以及全局事务指定的`Cancel`方法(`OrderCreateCancel`)会被调用，账号分支事务指定(`DeductBalanceCancel`)的`Cancel`方法都不会被执行。

9. 如果在**步骤3**就出现异常(用户的账号余额不足,访问数据库出现异常等),那么库存分支事务(`DeductStockCancel`)和账号分支事务指定(`DeductBalanceCancel`)全局事务指定的`Cancel`方法(`OrderCreateCancel`)都会被调用。

::: tip 提示

全局事务的`Cancel`方法一定会被调用。如果分支事务的`Try`方法得到执行(分支事务的状态为`trying`),那么将会执行分支事务指定的`Cancel`方法。如果分支事务的分支事务的`Try`方法没有得到执行(分支事务的状态为`pretry`),那么不会执行分支事务指定的`Cancel`方法。

:::

## lms分布式事务的使用

在lms框架中,在应用服务接口通过`[Transaction]`特性标识该接口是一个分布式事务接口(应用接口层需要安装包`Silky.Lms.Transaction`)。应用服务接口的实现必须需要通过`   [TccTransaction(ConfirmMethod = "ConfirmMethod", CancelMethod = "CancelMethod")]`特性指定Confirm阶段和Cancel阶段的方法(需要再应用层安装包`Silky.Lms.Transaction.Tcc`)。

在一个分布式事务处理过程中,会存在如下两种角色的事务。

::: warning 注意

应用接口被分布式事务`[Transaction]`特性标识,那么应用接口的实现也必须要使用`TccTransaction`特性来标识。否则,应用在启动时会抛出异常。

:::

### 事务角色

1. 全局事务

在Lms框架中,第一个执行的事务被认为是全局事务(事务角色为`TransactionRole.Start`)。换句话说,在一个业务处理过程中,执行的第一个被标识为`TccTransaction`(应用接口需要被标识为`Transaction`)的方法为全局事务。

当然,全局事务也作为事务的一特殊的事务参与者。

2. 分支事务

在开始的一个分布式事务中,参与rpc通信,且被特性`[Transaction]`标识的应用服务,被认为是分支事务(事务角色为:`TransactionRole.Participant`)。

### 事务的执行

1. 在开启一个全局事务之后,在全局事务的`try`过程中，首先将全局事务作为一个事务参与者添加到事务上下文中。如果遇到一个分支事务,那么首先会调用分支事务的`try`方法。如果`try`方法执行成功，那么分支事务作为一个事务参与者被注册到事务上下文中,并且分支的事务状态为变更为`trying`。
 
2. 如果在全局事务的try方法执行过程中发生异常,那么全局事务的`Cancel`方法和被加入事务上下文且状态为`trying`的分支事务参与者的`Cancel`方法将会被调用,在`Cancel`方法中实现数据回滚。也就是说,全局事务的`Cancel`不管`try`方法是否执行成功,全局事务的`Cancel`方法都会被执行。分支事务只有被加入到事务上下文,且状态为`trying`(分支事务已经执行过`try`方法),那么分支事务的`Cancel`方法才会被执行。
 
3. 全局事务的try方法执行成功,那么全局事务的`Confirm`和各个分支事务的`Confirm`方法将会得到执行。

::: warning 注意

无论是全局事务还是分支事务的各个阶段,如果涉及到多个表的操作,那么,对应的每个阶段的都需要本地事务进行操作。

:::

## 分布式事务案例


### 全局事务--订单接口


### 分支事务--扣减库存

### 分支事务--扣减账户余额
